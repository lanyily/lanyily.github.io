<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh" /><updated>2023-10-12T22:44:43+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gelei Blog</title><subtitle>格蕾的C++技术博客, 涉及C++基础, 计算机图形学, 三维动作捕捉, 游戏引擎开发, 音视频处理等
</subtitle><author><name>Ge Lei</name><email>&lt;mail@domain.tld&gt;</email></author><entry><title type="html">简单工厂模式</title><link href="http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2023-09-22-design-pattern/" rel="alternate" type="text/html" title="简单工厂模式" /><published>2023-09-22T00:00:00+08:00</published><updated>2023-10-10T00:24:25+08:00</updated><id>http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design-pattern</id><content type="html" xml:base="http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2023-09-22-design-pattern/"><![CDATA[<p>定义一个工厂类，其成员函数可以根据不同的参数创建并返回不同的类对象，调用者无需关注创建细节</p>

<h2 id="简介">简介</h2>

<p>模式：简单工厂</p>

<p>英文：simple factory</p>

<p>定义：定义一个工厂类，其成员函数可以根据不同的参数创建并返回不同的类对象，调用者无需关注创建细节</p>

<p>意图：实例化的活动不应该总是公开地进行，为了避免初始化总是造成耦合问题，将两者解耦</p>

<h2 id="设计准则">设计准则</h2>

<ol>
  <li><strong><em>对修改关闭，对扩展开放</em></strong>：增加新功能不应该修改已经存在的代码，而应该通过增加新类或新成员函数</li>
  <li><strong><em>针对接口编程，不针对实现编程</em></strong></li>
  <li><strong><em>依赖倒置原则：要依赖抽象，不要依赖具体类</em></strong>：不能让高层组件依赖低层组件，而且两者都应该依赖于抽象</li>
  <li><strong><em>封装变化</em></strong>：将容易变化的代码段限制在一个小范围内</li>
</ol>

<h2 id="代码">代码</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Role</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Role</span><span class="p">(</span><span class="kt">int</span> <span class="n">life</span><span class="p">,</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attack</span><span class="p">)</span> <span class="o">:</span><span class="n">m_life</span><span class="p">(</span><span class="n">life</span><span class="p">),</span> <span class="n">m_magic</span><span class="p">(</span><span class="n">magic</span><span class="p">),</span> <span class="n">m_attack</span><span class="p">(</span><span class="n">attack</span><span class="p">)</span> <span class="p">{}</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">Role</span><span class="p">(){}</span>
<span class="k">protected</span><span class="o">:</span>
	<span class="kt">int</span> <span class="n">m_life</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m_magic</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m_attack</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">R_A</span> <span class="o">:</span><span class="k">public</span> <span class="n">Role</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">R_A</span><span class="p">(</span><span class="kt">int</span> <span class="n">life</span><span class="p">,</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attack</span><span class="p">)</span> <span class="o">:</span><span class="n">Role</span><span class="p">(</span><span class="n">life</span><span class="p">,</span> <span class="n">magic</span><span class="p">,</span> <span class="n">attack</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"创建A角色"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">R_B</span> <span class="o">:</span><span class="k">public</span> <span class="n">Role</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">R_B</span><span class="p">(</span><span class="kt">int</span> <span class="n">life</span><span class="p">,</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attack</span><span class="p">)</span> <span class="o">:</span><span class="n">Role</span><span class="p">(</span><span class="n">life</span><span class="p">,</span> <span class="n">magic</span><span class="p">,</span> <span class="n">attack</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"创建B角色"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">R_C</span> <span class="o">:</span><span class="k">public</span> <span class="n">Role</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">R_C</span><span class="p">(</span><span class="kt">int</span> <span class="n">life</span><span class="p">,</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attack</span><span class="p">)</span> <span class="o">:</span><span class="n">Role</span><span class="p">(</span><span class="n">life</span><span class="p">,</span> <span class="n">magic</span><span class="p">,</span> <span class="n">attack</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"创建C角色"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">RoleFactory</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Role</span><span class="o">*</span> <span class="n">createRole</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">roletype</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Role</span><span class="o">*</span> <span class="n">p_Role</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">roletype</span><span class="o">==</span><span class="s">"A"</span><span class="p">)</span>
			<span class="n">p_Role</span><span class="o">=</span><span class="k">new</span> <span class="n">R_A</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">roletype</span><span class="o">==</span><span class="s">"C"</span><span class="p">)</span>
			<span class="n">p_Role</span> <span class="o">=</span> <span class="k">new</span> <span class="n">R_C</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">roletype</span> <span class="o">==</span> <span class="s">"B"</span><span class="p">)</span>
			<span class="n">p_Role</span> <span class="o">=</span> <span class="k">new</span> <span class="n">R_B</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">800</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">p_Role</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">RoleFactory</span> <span class="n">rolefactory</span><span class="p">;</span>
	<span class="n">Role</span><span class="o">*</span> <span class="n">p_role1</span> <span class="o">=</span> <span class="n">rolefactory</span><span class="p">.</span><span class="n">createRole</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
	<span class="n">Role</span><span class="o">*</span> <span class="n">p_role2</span> <span class="o">=</span> <span class="n">rolefactory</span><span class="p">.</span><span class="n">createRole</span><span class="p">(</span><span class="s">"C"</span><span class="p">);</span>
	<span class="n">Role</span><span class="o">*</span> <span class="n">p_role3</span> <span class="o">=</span> <span class="n">rolefactory</span><span class="p">.</span><span class="n">createRole</span><span class="p">(</span><span class="s">"B"</span><span class="p">);</span>
	<span class="k">delete</span> <span class="n">p_role1</span><span class="p">;</span>
	<span class="k">delete</span> <span class="n">p_role2</span><span class="p">;</span>
	<span class="k">delete</span> <span class="n">p_role3</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由于创建角色与角色工厂本身无关，所以可以使用static方法，也就是是静态工厂方法模式</p>

<pre><code class="language-C++">#include &lt;iostream&gt;
class Role {
public:
	Role(int life, int magic, int attack) :m_life(life), m_magic(magic), m_attack(attack) {}
	virtual ~Role() {}
protected:
	int m_life;
	int m_magic;
	int m_attack;
};

class R_A :public Role {
public:
	R_A(int life, int magic, int attack) :Role(life, magic, attack)
	{
		std::cout &lt;&lt; "创建A角色" &lt;&lt; std::endl;
	}
};
class R_B :public Role {
public:
	R_B(int life, int magic, int attack) :Role(life, magic, attack)
	{
		std::cout &lt;&lt; "创建B角色" &lt;&lt; std::endl;
	}
};
class R_C :public Role {
public:
	R_C(int life, int magic, int attack) :Role(life, magic, attack)
	{
		std::cout &lt;&lt; "创建C角色" &lt;&lt; std::endl;
	}
};
class RoleFactory
{
public:
	static Role* createRole(std::string roletype)
	{
		Role* p_Role = nullptr;
		if (roletype == "A")
			p_Role = new R_A(300, 400, 1000);
		else if (roletype == "C")
			p_Role = new R_C(1000, 400, 500);
		else if (roletype == "B")
			p_Role = new R_B(400, 400, 800);
		return p_Role;
	}
};

int main() {
	Role* p_role1 = RoleFactory::createRole("A");
	Role* p_role2 = RoleFactory::createRole("C");
	Role* p_role3 = RoleFactory::createRole("B");
	delete p_role1;
	delete p_role2;
	delete p_role3;
	return 0;
}
</code></pre>

<h2 id="缺点">缺点</h2>

<p>当引入新的子类时，需要修改createRole函数的源码，违背了开闭准则</p>

<h2 id="使用场景">使用场景</h2>

<h2 id="相关模式">相关模式</h2>]]></content><author><name>Ge Lei</name><email>&lt;mail@domain.tld&gt;</email></author><category term="设计模式" /><summary type="html"><![CDATA[实例化的活动不应该总是公开地进行，为了避免初始化总是造成耦合问题，将两者解耦]]></summary></entry><entry><title type="html">享元模式</title><link href="http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2023-09-15-design-pattern/" rel="alternate" type="text/html" title="享元模式" /><published>2023-09-15T00:00:00+08:00</published><updated>2023-10-10T00:18:09+08:00</updated><id>http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design-pattern</id><content type="html" xml:base="http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2023-09-15-design-pattern/"><![CDATA[<p>本文介绍享元模式</p>

<h2 id="简介">简介</h2>

<p>模式：享元模式</p>

<p>英文：flyweight</p>

<p>定义：使用共享技术有效地支持大量细粒度的对象的复用，从而到达使用大量相似对象的同样的效果。</p>

<p>命名由来：flyweight是特轻量级，蝇量级的意思</p>

<p>意图：在同类对象十分多的情况下，改变模式，当需要某个对象时，尽量共用已经创建出来的同类对象，从而避免频繁new，节约内存，提高效率。</p>

<h2 id="概念">概念</h2>

<p>享元：被共享的单元或者对象</p>

<p>内部状态：存储在享元对象内部的，一直不会发生改变的状态，这种状态可以被共享，一般可以作为享元类的成员变量</p>

<p>外部状态：随着外部环境改变而改变的状态，不可以被共享</p>

<p>总之，将内部状态相同的对象存储在享元池中，传递不同的外部状态。确定内部状态的时候，需要将在多个地方共享的成员变量作为享元对象的内部状态</p>

<h3 id="享元池">享元池</h3>

<p>享元模式中使用了简单工厂，这个工厂一般用于创建享元对象，并保存在一个容器中，这个容器专门用于保存一个或者多个享元对象，称为享元池</p>

<p>享元池的引入造成了程序的复杂性，需要衡量性价比</p>

<p>享元池和对象池，连接池，线程池都可以看成是对象的复用，但是后三者强调储备量，比如线程池可以规定线程池中线程数最多为多少，但是享元池强调的是创建对象这个过程可以使用享元池中的已有一种对象进行代替</p>

<h2 id="代码结构">代码结构</h2>

<p>一般由以下几个部分组成</p>

<ol>
  <li>抽象享元类：Piece</li>
  <li>具体享元类：BlackPiece，可以考虑使用单件模式实现</li>
  <li>享元工厂类：pieceFactory，可以考虑使用单件模式实现</li>
</ol>

<h2 id="代码">代码</h2>

<p>使用享元模式前：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;list&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="n">EnumColor</span> <span class="p">{</span>
	<span class="n">Black</span><span class="p">,</span><span class="n">White</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">Position</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">m_x</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">m_y</span><span class="p">;</span>
	<span class="n">Position</span><span class="p">(</span><span class="kt">int</span> <span class="n">tmpx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tmpy</span><span class="p">)</span> <span class="o">:</span><span class="n">m_x</span><span class="p">(</span><span class="n">tmpx</span><span class="p">),</span> <span class="n">m_y</span><span class="p">(</span><span class="n">tmpy</span><span class="p">){}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Piece</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Piece</span><span class="p">(</span><span class="n">EnumColor</span> <span class="n">tmpcolor</span><span class="p">,</span> <span class="n">Position</span> <span class="n">tmppos</span><span class="p">)</span> <span class="o">:</span><span class="n">m_color</span><span class="p">(</span><span class="n">tmpcolor</span><span class="p">),</span> <span class="n">m_pos</span><span class="p">(</span><span class="n">tmppos</span><span class="p">)</span> <span class="p">{</span>

	<span class="p">}</span>
	<span class="kt">void</span> <span class="nf">draw</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">EnumColor</span> <span class="n">m_color</span><span class="p">;</span>
	<span class="n">Position</span> <span class="n">m_pos</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">Piece</span><span class="o">::</span><span class="n">draw</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_color</span> <span class="o">==</span> <span class="n">Black</span><span class="p">){</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"绘制黑棋于"</span> <span class="o">&lt;&lt;</span> <span class="n">m_pos</span><span class="p">.</span><span class="n">m_x</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">m_pos</span><span class="p">.</span><span class="n">m_y</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"绘制白棋于"</span> <span class="o">&lt;&lt;</span> <span class="n">m_pos</span><span class="p">.</span><span class="n">m_x</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="n">m_pos</span><span class="p">.</span><span class="n">m_y</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

	<span class="n">Piece</span><span class="o">*</span> <span class="n">p_piece1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Piece</span><span class="p">(</span><span class="n">Black</span><span class="p">,</span> <span class="n">Position</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">p_piece1</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span>

	<span class="n">Piece</span><span class="o">*</span> <span class="n">p_piece2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Piece</span><span class="p">(</span><span class="n">White</span><span class="p">,</span> <span class="n">Position</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
	<span class="n">p_piece2</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span>

	<span class="n">Piece</span><span class="o">*</span> <span class="n">p_piece3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Piece</span><span class="p">(</span><span class="n">Black</span><span class="p">,</span> <span class="n">Position</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span>
	<span class="n">p_piece3</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span>

	<span class="n">std</span><span class="o">::</span><span class="n">list</span> <span class="o">&lt;</span><span class="n">Piece</span><span class="o">*&gt;</span><span class="n">piece_list</span><span class="p">;</span>
	<span class="n">piece_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p_piece1</span><span class="p">);</span>
	<span class="n">piece_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p_piece2</span><span class="p">);</span>
	<span class="n">piece_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p_piece3</span><span class="p">);</span>

	<span class="k">delete</span> <span class="n">p_piece1</span><span class="p">;</span>
	<span class="k">delete</span> <span class="n">p_piece2</span><span class="p">;</span>
	<span class="k">delete</span> <span class="n">p_piece3</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用享元模式后：</p>

<pre><code class="language-C++">#include&lt;iostream&gt;
#include&lt;list&gt;
#include&lt;map&gt;
enum EnumColor {
	Black, White
};
struct Position {
	int m_x;
	int m_y;
	Position(int tmpx, int tmpy) :m_x(tmpx), m_y(tmpy) {}
};
class Piece
{
public:
	virtual ~Piece() {};
	virtual void draw(Position tmppos)=0;
};
class BlackPiece:public Piece {
public:
	virtual void draw(Position tmppos) {
		std::cout &lt;&lt; "绘制黑棋于" &lt;&lt; tmppos.m_x &lt;&lt; "," &lt;&lt; tmppos.m_y &lt;&lt; std::endl;
	}
};
class WhitePiece :public Piece {
public:
	virtual void draw(Position tmppos) {
		std::cout &lt;&lt; "绘制白棋于" &lt;&lt; tmppos.m_x &lt;&lt; "," &lt;&lt; tmppos.m_y &lt;&lt; std::endl;
	}
};
class pieceFactory {
public:
	~pieceFactory()
	{
		for (auto iter = m_FlyWeightMap.begin(); iter != m_FlyWeightMap.end(); iter++)
		{
			Piece* tmpfw = iter-&gt;second;
			delete tmpfw;
		}
		m_FlyWeightMap.clear();
	}
	Piece* getFlyWeight(EnumColor tmpcolor)
	{
		auto iter = m_FlyWeightMap.find(tmpcolor);
		if(iter==m_FlyWeightMap.end())
		{
			Piece* tmpfw = nullptr;
			if (tmpcolor == Black) tmpfw = new BlackPiece();
			else tmpfw = new WhitePiece();
			m_FlyWeightMap.insert(std::make_pair(tmpcolor, tmpfw));
			return tmpfw;
		}
		else 
			return iter-&gt;second;
	}
private:
	std::map&lt;EnumColor, Piece*&gt;m_FlyWeightMap;
};
int main()
{
	pieceFactory* pfactory = new pieceFactory();
	Piece* p_piece1 = pfactory-&gt;getFlyWeight(Black);
	p_piece1-&gt;draw(Position(3, 3));

	Piece* p_piece2 = pfactory-&gt;getFlyWeight(Black);
	p_piece2-&gt;draw(Position(5, 5));

	Piece* p_piece3 = pfactory-&gt;getFlyWeight(Black);
	p_piece3-&gt;draw(Position(4, 6));

	Piece* p_piece4 = pfactory-&gt;getFlyWeight(Black);
	p_piece4-&gt;draw(Position(5, 7));

	delete pfactory;
	return 0;
}
</code></pre>

<p>关闭命令行输出时两种代码创建相同数量的类的运行速度：</p>

<table>
  <thead>
    <tr>
      <th>对象数/ms</th>
      <th>普通模式</th>
      <th>享元模式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000（波动大）</td>
      <td>400</td>
      <td>170-356</td>
    </tr>
    <tr>
      <td>一万</td>
      <td>2572</td>
      <td>1800-2200</td>
    </tr>
    <tr>
      <td>十万</td>
      <td>19643-33911</td>
      <td>15749-16401</td>
    </tr>
    <tr>
      <td>百万</td>
      <td>249130-216128</td>
      <td>159932</td>
    </tr>
    <tr>
      <td>千万</td>
      <td>2417764-2123181</td>
      <td>1616665-1656742</td>
    </tr>
    <tr>
      <td>一亿</td>
      <td>19677707-20324193</td>
      <td>15560363</td>
    </tr>
  </tbody>
</table>

<p>可以看出来性能提升还不小，优化了25%左右</p>

<h2 id="使用场景">使用场景</h2>

<ol>
  <li>程序中有大量相同或者相似的对象造成内存的大量消耗</li>
  <li>对象的大部分状态可以定义为外部状态作为参数传入</li>
</ol>

<h2 id="相关模式">相关模式</h2>

<ol>
  <li>简单工厂模式</li>
  <li>单件模式</li>
</ol>]]></content><author><name>Ge Lei</name><email>&lt;mail@domain.tld&gt;</email></author><category term="设计模式" /><summary type="html"><![CDATA[在同类对象十分多的情况下，改变模式，当需要某个对象时，尽量共用已经创建出来的同类对象，从而避免频繁创建，节约内存，提高效率]]></summary></entry><entry><title type="html">模版方法模式</title><link href="http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/666/" rel="alternate" type="text/html" title="模版方法模式" /><published>2023-09-01T00:00:00+08:00</published><updated>2023-10-12T22:43:59+08:00</updated><id>http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design-pattern</id><content type="html" xml:base="http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/666/"><![CDATA[<p>本文介绍模版方法模式</p>

<h2 id="简介">简介</h2>

<p>模式名：模版方法模式</p>

<p>英文：template method</p>

<p>定义：由固定步骤组成的事情，在步骤确定的情况下，通过多态在子类中对每步进行差异性实现。</p>

<p>命名由来：某个成员方法，称为A，固定调用某几个成员方法，故称A为模版方法，这种方法叫做模版方法模式</p>

<p>意图：定义一个操作的算法骨架，将一些步骤延迟到子类实现，通过父类定义虚函数，子类重写/实现来做到</p>

<h2 id="概念">概念</h2>

<h3 id="早绑定与晚绑定">早绑定与晚绑定</h3>

<p>早绑定：编译阶段就知道代码调用的哪个类的方法</p>

<p>晚绑定：父类指针指向子类对象，运行期间才能知道调用哪种方法</p>

<h3 id="钩子方法hook">钩子方法hook</h3>

<p>子类可以控制父类的行为的方法</p>

<h2 id="使用场景">使用场景</h2>

<h3 id="mfc">MFC</h3>

<p>MFC创建对话框的应用程序</p>

<h3 id="车间">车间</h3>

<p>零件装配工序固定，则针对零件创建一个父类，零件装配工序采用模版方法模式来实现，处理某道工序的细节可以放在子类的虚函数中</p>

<h2 id="相关模式">相关模式</h2>]]></content><author><name>Ge Lei</name><email>&lt;mail@domain.tld&gt;</email></author><category term="设计模式" /><summary type="html"><![CDATA[由固定步骤组成的事情，在步骤确定的情况下，通过多态在子类中对每步进行差异性实现]]></summary></entry></feed>